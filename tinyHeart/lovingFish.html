<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>爱心鱼</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        body{
            background-image:url("src/tianmaobg.jpg");
            background-position: 0 130px;
            background-size: 1280px;
        }
        header{
            width: 1280px;
            height: 184px;
        }
        header>img{
            width: 1280px;
        }
        .all_bg{
            width: 800px;
            height: 600px;
            margin: 0 auto;
            overflow: hidden;
        }
        #allcanvas{
            width: 800px;
            height: 600px;
            margin: 0 auto;
            position: absolute;
            top: 320px;
        }
        #canvas1{
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 1;
        }
        #canvas2{
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }
        .gameName{
            width: 1280px;
            height: 200px;
            text-align: center;
            line-height: 200px;
            color: white;
            font-size: 60px;
            /*background: firebrick;*/
        }
    </style>
</head>
<body>
    <header><img src="src/tianmao1.png"></header>
    <div class="gameName"><p>玩游戏！抢红包！</p></div>
    <div class="all_bg" >
        <div id="allcanvas">
            <canvas id="canvas1" width="800" height="600"></canvas>
            <canvas id="canvas2" width="800" height="600"></canvas>
        </div>
    </div>
</body>
<script charset="utf-8" src="./js/commonFunctions.js"></script>
<script charset="utf-8">
    var can1,can2,ctx1,ctx2;
    var lastTime;//上一帧执行的时间
    var deltaTime;//两帧间隔的时间差

    var bgPic = new Image();
    var canWidth,canHeight;
    var ane;        //海葵

    var fruit;      //海葵果实

    var mom;        //妈妈鱼

    var mx,my;   //鼠标的坐标

    var baby;       //小鱼

    var babyTail = [];  //小鱼尾巴动态序列帧的图片存储
    var babyEye = [];   //存放小鱼眨眼图片的数组
    var babyBody = [];   //存放小鱼身体变白的图片的数组

    var momTail=[];         //大鱼尾巴动态序列帧的图片存储
    var momEye = [];        //存放大鱼眨眼图片的数组
    var momBodyOrg=[];      //鱼妈妈橙色身体
    var momBodyBlue=[];     //鱼妈妈蓝色身体

    var data;

    var wave;               //鱼妈妈吃果实产生的白色的圈
    var halo;               //鱼妈妈喂小鱼产生的圆圈

    var dust;               //绘制漂浮物
    var dustPic = [];       //存放漂浮物的图片

    document.body.onload=game;
    function game(){
        init();
        lastTime=Date.now();
        deltaTime=0;
        gameloop();
    }


    function init(){
        can1=document.getElementById("canvas1");    //前，鱼
        ctx1=can1.getContext("2d");
        can2=document.getElementById("canvas2");    //后，背景、海葵
        ctx2=can2.getContext("2d");

        can1.addEventListener('mousemove',onMouseMove,false);

        bgPic.src = "./src/background.jpg";
        canWidth = can1.width;
        canHeight = can1.height;

        ane= new aneObj();
        ane.init();

        fruit= new fruitObj();
        fruit.init();

        mom= new momObj();
        mom.init();

        baby= new babyObj();
        baby.init();

        mx=canWidth*0.5;
        my=canHeight*0.5;

        for(var i= 0;i<8;i++)           //小鱼的尾巴的图片添加到数组里
        {
            babyTail[i]=new Image();
            babyTail[i].src="./src/babyTail"+i+".png";
        }

        for(var i=0;i<2;i++)            //小鱼眨眼睛的图片放在数组里
        {
            babyEye[i]=new Image();
            babyEye[i].src="./src/babyEye"+i+".png";
        }

        for(var i=0;i<20;i++)            //小鱼身体变白的图片放在数组里
        {
            babyBody[i]=new Image();
            babyBody[i].src="./src/babyFade"+i+".png";
        }

        for(var i= 0;i<8;i++)           //大鱼的尾巴的图片添加到数组里
        {
            momTail[i]=new Image();
            momTail[i].src="./src/bigTail"+i+".png";
        }

        for(var i=0;i<2;i++)            //大鱼眨眼睛的图片放在数组里
        {
            momEye[i]=new Image();
            momEye[i].src="./src/bigEye"+i+".png";
        }

        for(var i=0;i<8;i++)            //鱼妈妈身体变化的图片放在数组里
        {
            momBodyOrg[i]=new Image();
            momBodyOrg[i].src="./src/bigSwim"+i+".png";
            momBodyBlue[i]=new Image();
            momBodyBlue[i].src="./src/bigSwimBlue"+i+".png";
        }

        data=new dataObj();
        ctx1.font= "30px Verdana";      //定义显示分数的字体样式
        ctx1.textAlign= "center";

        wave = new waveObj();           //鱼妈妈吃果实的特效初始化
        wave.init();

        halo = new haloObj();           //鱼妈妈喂小雨的特效
        halo.init();

        for(var i=0;i<7;i++)
        {
            dustPic[i] = new Image();
            dustPic[i].src="./src/dust"+i+".png";
        }

        dust = new dustObj();
        dust.init();
    }


    function gameloop(){
        requestAnimationFrame(gameloop);  //当前绘制完成之后。他会根据机器的性能决定下一次绘制的间隔时间多长，比较智能，作用与setInterval查不多,但是这个每两帧的时间差不一样
        var now=Date.now();
        deltaTime=now-lastTime;
        lastTime=now;
        if(deltaTime>40){
            deltaTime=40;
        }
        drawBackground();
        ane.draw();
        fruit.draw();
        fruitMonitor();

        ctx1.clearRect(0,0,canWidth,canHeight);
        mom.draw();

        baby.draw();

        momFruitCollision();
        momBabyCollision();

        data.draw();          //将大鱼的分数打印出来
        wave.draw();          //大鱼吃到果实的特效
        halo.draw();          //鱼妈妈喂食的特效
        dust.draw();          //绘制漂浮物
    }


    function onMouseMove(e)
    {   if(!data.gameOver)
        {
            if(e.offsetX || e.layerX) {
                mx= e.offsetX == undefined? e.layerX: e.offsetX;
                my= e.offsetY == undefined? e.layerY: e.offsetY;
            }
        }
    }



    /*******(1)绘制背景********/
    function drawBackground(){
        ctx2.drawImage(bgPic,0,0,canWidth,canHeight)
    }
    /*******(2)绘制海葵********/
    var aneObj = function(){        //定义海葵的一个类
        this.rootx=[];      //贝塞尔曲线开始点，控制点可以更根据这个开始点取得
        this.headx=[];      //结束点，可以通过正弦函数控制摆动
        this.heady=[];      //头部的y坐标
        this.amp = [];      //摆动的振幅
        this.alpha=0;       //正弦函数
    };
    aneObj.prototype.num=50;        //50条海葵

    aneObj.prototype.init = function(){     //初始化，确定这个海葵的初始位置
        for(var i=0;i<this.num;i++){
            this.rootx[i]=i*16+Math.random()*20;   //水平绘制海葵的位置 间距
            this.headx[i]=this.rootx[i];
            this.heady[i]=canHeight - 250 + Math.random()*50;
            this.amp[i] = Math.random()*50+50;
        }
    };

    aneObj.prototype.draw = function(){
        this.alpha+=deltaTime*0.0008;
        var l=Math.sin(this.alpha);         //定义正弦值[-1,1]
        ctx2.save();
        ctx2.globalAlpha=0.6;
        ctx2.lineWidth = 20;
        ctx2.lineCap="round";
        ctx2.strokeStyle = "#3b154e";
        for(var i= 0 ;i <this.num;i++){  //绘制海葵
            ctx2.beginPath();
            ctx2.moveTo(this.rootx[i],canHeight);
            this.headx[i] = this.rootx[i] +  l * this.amp[i];
            ctx2.quadraticCurveTo(this.rootx[i],canHeight - 100, this.headx[i],this.heady[i]);
            ctx2.stroke();
        }
        ctx2.restore();
    };

    /*******(3)绘制果实********/
    var fruitObj=function(){        //定义一个果实类
        this.alive=[];   //布尔值，是否活着
        this.x=[];      //记录坐标值
        this.y=[];
        this.aneNO = [];
        this.l=[];      //定义果实的大小
        this.spd=[];        //向上移动速度
        this.fruitType=[];      //果实类型
        this.orange=new Image();
        this.blue=new Image();
    };

    fruitObj.prototype.num = 30;   //定义一个数量

    fruitObj.prototype.init=function(){   //初始化
        for(var i=0;i<this.num;i++){
            this.alive[i]=false;
            this.x[i]=0;
            this.y[i]=0;
            this.aneNO[i]=0;
            this.spd[i]=Math.random()*0.017+0.003;      //[0.005-0.015)  向上移动速度
            this.fruitType[i]="";
//            this.born(i);
        }
        this.orange.src="./src/fruit.png";      //引入果实
        this.blue.src="./src/blue.png";
    };

    fruitObj.prototype.draw=function(){         //画果实
        for(var i= 0; i<this.num;i++){
            if(this.alive[i]){
                var pic;
                if(this.fruitType[i]=="blue"){
                    pic=this.blue;
                }
                else{
                    pic=this.orange;
                }
                if(this.l[i]<=14){
                    var NO=this.aneNO[i];
                    this.x[i] = ane.headx[NO];
                    this.y[i] = ane.heady[NO];
                    this.l[i]+=0.01*deltaTime;
                    ctx2.drawImage(pic,this.x[i]-this.l[i]*0.5,this.y[i]-this.l[i]*0.5,this.l[i],this.l[i]);
                }
                else{
                    this.y[i]-=this.spd[i]*5*deltaTime;
                    ctx2.drawImage(pic,this.x[i]-this.l[i]*0.5,this.y[i]-this.l[i]*0.5,this.l[i],this.l[i]);
                }

                if(this.y[i]<-10){
                    this.alive[i]=false;
                }
            }
        }

    };

    fruitObj.prototype.born = function(i){
//        var aneID= Math.floor(Math.random()*ane.num);
//        this.x[i]=ane.headx[aneID];     //对应果实的X轴，Y轴
//        this.y[i]=ane.heady[aneID];
        this.aneNO[i] = Math.floor(Math.random()*ane.num);
        this.l[i]=0;
        this.alive[i]=true;
        var ran=Math.random();
        if(ran<0.2){
            this.fruitType[i]="blue" ;
        }
        else{
            this.fruitType[i]="orange";
        }

    };

    fruitObj.prototype.dead=function(i){    //果实时候被吃掉的
        this.alive[i]=false;
    };

    function fruitMonitor(){            //果实监视功能。监视页面中果实的数量
        var num=0;
        for(var i=0;i<fruit.num;i++){
            if(fruit.alive[i]){
                num++;
            }
            if(num<15){
                sendFruit();
                return;
            }
        }
    }

    function sendFruit(){               //调用出生果实函数
        for(var i=0;i<fruit.num;i++){
            if(!fruit.alive[i]){
                fruit.born(i);
                return;
            }
        }
    }

    /*******(4)绘制大鱼********/

    var momObj=function(){
        this.x=0;           //大鱼的坐标
        this.y=0;

        this.momTailTimer=0;       //尾巴每一帧间隔时间
        this.momTailCount=0;       //尾巴每一帧对应的图片

        this.momEyeTimer=0;       //大鱼眼睛每一帧间隔时间
        this.momEyeCount=0;       //大鱼眼睛每一帧对应的图片
        this.momEyeInterval=1000;       //大鱼眨眼睛的时间间隔

        this.momBodyCount=0;        //
    };
    momObj.prototype.init=function(){
        this.x=canWidth*0.5;     //大鱼的坐标
        this.y=canHeight*0.5;
        this.angle = 0;      //大鱼的角度
    };
    momObj.prototype.draw=function(){

        this.x =lerpDistance(mx, this.x, 0.98);          //大鱼跟随鼠标移动，定义的这个函数在方法JS中
        this.y =lerpDistance(my, this.y, 0.98);

        var deltaY=my-this.y;
        var deltaX=mx-this.x;
        var beta = Math.atan2(deltaY,deltaX)+Math.PI;

        this.angle=lerpAngle(beta,this.angle,0.6);         //大鱼获得的角度,定义的这个函数在方法JS中

        this.momTailTimer+=deltaTime;
        if(this.momTailTimer>50)
        {
            this.momTailCount= (this.momTailCount + 1)%8;   //对8取模，确保这个值的范围为[0,7]
            this.momTailTimer %=50;
        }

        this.momEyeTimer+=deltaTime;                      //大鱼眨眼睛频率的时间设置
        if(this.momEyeTimer > this.momEyeInterval)
        {
            this.momEyeCount= (this.momEyeCount + 1)%2;   //对2取模，确保这个值的范围为[0,1]
            this.momEyeTimer %=this.momEyeInterval;
            if(this.momEyeCount==0)                        //判断当前眼睛是睁着还是闭着，
            {
                this.momEyeInterval = Math.random()*1500+2000;    //[2000,3500)        睁着的时候设置
            }
            else{
                this.momEyeInterval = 200;                 //闭着的时间设置
            }
        }

        ctx1.save();
        ctx1.translate(this.x,this.y);
        ctx1.rotate(this.angle);
        var momTailCount=this.momTailCount;
        ctx1.drawImage(momTail[momTailCount],-momTail[momTailCount].width*0.5+30,-momTail[momTailCount].height*0.5);
        var momBodyCount=this.momBodyCount;
        if( data.double == 1)            //判断其吃的是设么颜色的果实。然后来决定应该绘制什么颜色的身体
        {
            ctx1.drawImage(momBodyOrg[momBodyCount],-momBodyOrg[momBodyCount].width*0.5,-momBodyOrg[momBodyCount].height*0.5);
        }
        else
        {
            ctx1.drawImage(momBodyBlue[momBodyCount],-momBodyBlue[momBodyCount].width*0.5,-momBodyBlue[momBodyCount].height*0.5);
        }
        var momEyeCount=this.momEyeCount;
        ctx1.drawImage(momEye[momEyeCount],-momEye[momEyeCount].width*0.5,-momEye[momEyeCount].height*0.5);
        ctx1.restore();
    };

    /*******(5)碰撞检测的功能********/
    //判断大鱼和果实的距离
    function momFruitCollision()
    {   if(!data.gameOver)
        {
            for(var i=0;i<fruit.num;i++)
            {
                var l=calLength2(fruit.x[i], fruit.y[i], mom.x, mom.y);
                if(l<900){
                    if(fruit.alive[i]==true){
                        var a=fruit.x[i];
                        var b=fruit.y[i];
                        fruit.x[i]=-10;
                        fruit.y[i]=-10;
                        fruit.dead(i);
                        data.fruitNum++;        //果实死亡时。鱼妈妈吃到的果实++
                        mom.momBodyCount++;       //计数器。鱼妈妈身体颜色变化的计数器
                        if(mom.momBodyCount > 7)
                        {
                            mom.momBodyCount = 7;
                        }
                        if(fruit.fruitType[i]=="blue")                    //判断是否是蓝色的果实
                        {
                            data.double = 2;
                        }
                        wave.born(a,b);
                    }
                }
            }
        }
    }
    //判断鱼妈妈与小鱼的距离
    function momBabyCollision()
    {
        if(data.fruitNum > 0 && !data.gameOver)           //判断鱼妈妈是不是已经吃到果实了
        {
            var l = calLength2(mom.x,mom.y,baby.x,baby.y);
            if(l<900)
            {
                baby.babyBodyCount = 0;
                mom.momBodyCount = 0;
                data.addScore();
                halo.born(baby.x,baby.y)
            }
        }
    }



    /*******(6)绘制小鱼********/
    var babyObj=function()
    {
        this.x=0;
        this.y=0;
        this.angle=0;

        this.babyTailTimer=0;       //尾巴每一帧间隔时间
        this.babyTailCount=0;       //尾巴每一帧对应的图片

        this.babyEyeTimer=0;       //小鱼眼睛每一帧间隔时间
        this.babyEyeCount=0;       //小鱼眼睛每一帧对应的图片
        this.babyEyeInterval=1000;       //小鱼眨眼睛的时间间隔

        this.babyBodyTimer=0;       //身体变白每一帧间隔时间
        this.babyBodyCount=0;       //身体变白每一帧对应的图片


    };
    babyObj.prototype.init = function()
    {
        this.x=canWidth*0.5-50;
        this.y=canHeight*0.5+50;
        this.angle = 0;      //小鱼的角度
    };
    babyObj.prototype.draw = function()
    {
        this.x =lerpDistance(mom.x, this.x, 0.98);          //小鱼跟随大鱼移动，定义的这个函数在方法JS中
        this.y =lerpDistance(mom.y, this.y, 0.98);

        var deltaY=mom.y-this.y;
        var deltaX=mom.x-this.x;
        var beta = Math.atan2(deltaY,deltaX)+Math.PI;

        this.angle=lerpAngle(beta,this.angle,0.6);         //小鱼获得的角度,定义的这个函数在方法JS中

        this.babyTailTimer+=deltaTime;                      //小鱼尾巴摆动频率的时间设置
        if(this.babyTailTimer > 50)
        {
            this.babyTailCount= (this.babyTailCount + 1)%8;   //对8取模，确保这个值的范围为[0,7]
            this.babyTailTimer %=50;
        }

        this.babyEyeTimer+=deltaTime;                      //小鱼眨眼睛频率的时间设置
        if(this.babyEyeTimer > this.babyEyeInterval)
        {
            this.babyEyeCount= (this.babyEyeCount + 1)%2;   //对2取模，确保这个值的范围为[0,1]
            this.babyEyeTimer %=this.babyEyeInterval;
            if(this.babyEyeCount==0)                        //判断当前眼睛是睁着还是闭着，
            {
                this.babyEyeInterval = Math.random()*1500+2000;    //[2000,3500)        睁着的时候设置
            }
            else{
                this.babyEyeInterval = 200;                 //闭着的时间设置
            }
        }

        this.babyBodyTimer += deltaTime;
        if(this.babyBodyTimer > 300)
        {
            this.babyBodyCount = this.babyBodyCount+1;
            this.babyBodyTimer%=300;
            if(this.babyBodyCount>19)
            {
                this.babyBodyCount=19;          //游戏结束
                data.gameOver = true;
            }
        }

        ctx1.save();
        ctx1.translate(this.x,this.y);
        ctx1.rotate(this.angle);
        var  babyTailCount=this.babyTailCount;        //当前应该画的小鱼的尾巴具体图片
        ctx1.drawImage(babyTail[babyTailCount],-babyTail[babyTailCount].width*0.5+23,-babyTail[babyTailCount].height*0.5);
        var babyBodyCount=this.babyBodyCount;          //小鱼身体变白的动画
        ctx1.drawImage(babyBody[babyBodyCount],-babyBody[babyBodyCount].width*0.5,-babyBody[babyBodyCount].height*0.5);
        var  babyEyeCount=this.babyEyeCount;        //当前应该画的小鱼的尾巴具体图片
        ctx1.drawImage(babyEye[babyEyeCount],-babyEye[babyEyeCount].width*0.5,-babyEye[babyEyeCount].height*0.5);
        ctx1.restore();

    };




    /*******(7)分值计算********/
    var  dataObj=function()
    {
        this.fruitNum = 0;      //果实数量
        this.double = 1;        //每一个果实的分数值
        this.score = 0;         //记录总分数
        this.gameOver = false;  //记录游戏时候结束 ，false表示为结束
        this.alpha = 0;
    };
    dataObj.prototype.draw = function(){
        var w = can1.width;
        var h = can1.height;

        ctx1.save();
        ctx1.shadowBlur=10;
        ctx1.shadowColor="white";
        ctx1.fillStyle = "white";
        ctx1.fillText("num "+this.fruitNum,w*0.5,h-50);
        ctx1.fillText("double "+this.double,w*0.5,h-80);
        ctx1.fillText("score "+this.score,w*0.5,h-20);
        if(data.gameOver)       //判断游戏是否结束
        {
            this.alpha += deltaTime*0.0005;   //给结束游戏字样添加一个透明度渐变
            if(this.alpha>1){
                this.alpha=1;
            }
            ctx1.fillStyle="rgba(255,255,255,"+this.alpha+")";
            ctx1.fillText("Game Over ",w*0.5,h*0.5);
        }
        ctx1.restore();
    };
    dataObj.prototype.addScore = function()
    {
        this.score += this.fruitNum*100*this.double;
        this.fruitNum=0;
        this.double=1;
        if(this.score>5000){
            //根据分数提相应的奖励
        }
    };


    /*******(8)鱼妈妈吃果实的特效********/
    var waveObj = function()
    {
        this.x = [];
        this.y = [];
        this.alive = [];        //定义当前这个wave的状态，false表示没有执行任务。true表示执行任务
        this.r = [];            //半径
    };
    waveObj.prototype.num = 10;
    waveObj.prototype.init = function ()
    {
        for(var i = 0;i< this.num; i++)
        {
           this.alive[i] = false;
            this.r[i] = 0;
        }
    };
    waveObj.prototype.draw = function()
    {
        ctx1.save();
        ctx1.lineWidth = 2;
        ctx1.shadowBlur = 10;
        ctx1.shadowColor = "white";
      for(var i=0; i< this.num;i++)
      {
          if(this.alive[i])
          {
                this.r[i] += deltaTime * 0.04;
                  if(this.r[i] > 50)
                  {
                      this.alive[i] = false;
                      break;
                  }
                var alpha = 1- this.r[i]/50;
                ctx1.beginPath();
                ctx1.arc(this.x[i],this.y[i],this.r[i],0,Math.PI*2);
                ctx1.closePath();
                ctx1.strokeStyle = "rgba(255,255,255,"+alpha+")";
                ctx1.stroke();
          }
      }
        ctx1.restore();
    };
    waveObj.prototype.born = function(x,y)
    {
        for(var i=0; i< this.num;i++)
        {
            if(!this.alive[i])
            {
                this.alive[i] = true;
                this.r[i] = 10;
                this.x[i]=x;
                this.y[i]=y;
                return;     //如果找到，就跳出循环
            }
        }
    };


    /*******(9)鱼妈妈喂小鱼的特效********/
    var haloObj = function ()
    {
        this.x = [];
        this.y = [];
        this.alive = [];
        this.r = [];
    };
    haloObj.prototype.num = 5;
    haloObj.prototype.init = function()
    {
        for(var i=0;i < this.num; i++)
        {
            this.x[i] = 0;
            this.y[i] = 0;
            this.alive[i] = false;
            this.r[i] = 0;
        }
    };
    haloObj.prototype.draw = function()
    {
        ctx1.save();
        ctx1.lineWidth = 2;
        ctx1.shadowBlur = 10;
        ctx1.shadowColor = "rgba(203,91,0,1)";
        for(var i=0; i < this.num;i++)
        {
            if(this.alive[i])
            {
                //draw
                this.r[i] += deltaTime * 0.05;
                if(this.r[i] > 100)
                {
                    this.alive[i] = false;
                    break;
                }
                var alpha = 1 - this.r[i]/100;
                ctx1.beginPath();
                ctx1.arc(this.x[i],this.y[i],this.r[i],0,Math.PI*2);
                ctx1.closePath();
                ctx1.strokeStyle = "rgba(203,91,0,"+alpha+")";
                ctx1.stroke();
            }
        }
        ctx1.restore();
    };
    haloObj.prototype.born = function(x, y)
    {
        for(var i=0; i< this.num;i++)
        {
            if(!this.alive[i])
            {
                this.alive[i] = true;
                this.r[i] = 10;
                this.x[i]=x;
                this.y[i]=y;
                return;     //如果找到，就跳出循环
            }
        }
    };

    /*******(10)绘制漂浮物********/
    var dustObj=function()
    {
        this.x = [];
        this.y = [];
        this.amp = [];
        this.NO = [];

        this.alpha=0;
    };
    dustObj.prototype.num = 30;
    dustObj.prototype.init = function()
    {
        for(var i = 0;i < this.num;i++)
        {
            this.x[i] = Math.random() * canWidth;
            this.y[i] = Math.random() * canHeight;
            this.amp[i] = 20 + Math.random() * 25;
            this.NO[i] = Math.floor(Math.random() * 7);    //[0,7)
        }
        this.alpha = 0;
    };

    dustObj.prototype.draw = function()
    {
        this.alpha += deltaTime * 0.0008;
        var  l = Math.sin(this.alpha);
        for(var i = 0;i < this.num;i++)
        {
            var no = this.NO[i];
            ctx1.drawImage(dustPic[no],this.x[i] + this.amp[i] * l,this.y[i])
        }
    };

</script>
</html>